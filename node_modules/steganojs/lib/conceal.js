"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.conceal = void 0;
// Import downloaded module
var pngjs_1 = require("pngjs");
// Import custom functions
var encryption_1 = require("./encryption");
var png_1 = require("./png");
// Import constants
var defaults_1 = require("./defaults");
var getLengthData = function (message) {
    var lengthHex = message.length.toString(16);
    var lengthBuffer = Buffer.from(lengthHex.length % 2 ? "0".concat(lengthHex) : lengthHex, 'hex');
    var pad = Buffer.alloc(defaults_1.LENGTH_BYTES - lengthBuffer.length);
    return Buffer.concat([pad, lengthBuffer], defaults_1.LENGTH_BYTES);
};
var getBit = function (data) { return function (i) {
    var byteIndex = Math.floor(i / defaults_1.BYTE_SIZE);
    var bitIndex = i % defaults_1.BYTE_SIZE;
    var byte = data[byteIndex];
    var shiftDistance = defaults_1.BYTE_SIZE - 1 - bitIndex;
    /* tslint:disable:no-bitwise */
    return (byte >> shiftDistance) % 2;
    /* tslint:enable:no-bitwise */
}; };
/* tslint:disable:no-bitwise */
var addDataToByte = function (data) { return function (byte, i) { return ((byte >> 1) << 1) | getBit(data)(i); }; };
/* tslint:enable:no-bitwise */
var embedData = function (_a) {
    var data = _a[0], bed = _a[1];
    return bed.map(addDataToByte(data));
};
var store = function (imageData, message) {
    var bytesAvailable = imageData.length;
    var bytesToStore = defaults_1.LENGTH_BYTES + defaults_1.SHASUM_BYTES + message.length;
    var bytesRequired = (0, png_1.countBytesForNRgbBytes)(bytesToStore);
    if (bytesAvailable < bytesRequired)
        throw new Error('Image is not large enough to store message');
    var lengthData = getLengthData(message);
    var shasumData = (0, encryption_1.getShasumData)(message);
    var bytesToUse = imageData.slice(0, bytesRequired);
    var bytesToLeave = imageData.slice(bytesRequired);
    var _a = (0, png_1.splitRgbAndAlpha)(bytesToUse), rgb = _a[0], alpha = _a[1];
    var lengthDataSize = defaults_1.LENGTH_BYTES * defaults_1.BYTE_SIZE;
    var shasumDataSize = defaults_1.SHASUM_BYTES * defaults_1.BYTE_SIZE;
    var bytesToUseWithLengthData = rgb.slice(0, lengthDataSize);
    var bytesToUseWithShasumData = rgb.slice(lengthDataSize, lengthDataSize + shasumDataSize);
    var bytesToUseWithMessageData = rgb.slice(lengthDataSize + shasumDataSize);
    var embeddedData = Buffer.concat([
        [lengthData, bytesToUseWithLengthData],
        [shasumData, bytesToUseWithShasumData],
        [message, bytesToUseWithMessageData],
    ].map(embedData), rgb.length);
    var recombined = (0, png_1.recombineRgbAndAlpha)(embeddedData, alpha);
    var adjustedImageData = Buffer.concat([recombined, bytesToLeave], bytesAvailable);
    return adjustedImageData;
};
// export const conceal =
//   (password: string) =>
//   (image: Buffer, message: string | Buffer, encoding: BufferEncoding = 'utf-8') => {
//     const messageBuffer: Buffer = Buffer.isBuffer(message) ? message : Buffer.from(message, encoding);
//     const secretBuffer: Buffer = password ? encrypt(message, password) : messageBuffer;
//     const png: PNG = PNG.sync.read(image);
//     const data = store(png.data, secretBuffer);
//     const adjustedPng: PNG = Object.assign({}, png, { data });
//     return PNG.sync.write(adjustedPng);
//   };
var conceal = function (image, message, encoding, password) {
    var messageBuffer = Buffer.isBuffer(message) ? message : Buffer.from(message, encoding);
    var secretBuffer = password ? (0, encryption_1.encrypt)(messageBuffer, password) : messageBuffer;
    var png = pngjs_1.PNG.sync.read(image);
    var data = store(png.data, secretBuffer);
    var adjustedPng = Object.assign({}, png, { data: data });
    return pngjs_1.PNG.sync.write(adjustedPng);
};
exports.conceal = conceal;
