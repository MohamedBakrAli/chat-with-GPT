"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reveal = void 0;
// Import downloaded module
var pngjs_1 = require("pngjs");
// Import custom functions
var png_1 = require("./png");
var encryption_1 = require("./encryption");
// Import constants
var defaults_1 = require("./defaults");
var extractBinary = function (b) { return b % 2; };
var splitBitsAsBytes = function (bitsAsBytes) { return function (_, i) {
    var start = i * defaults_1.BYTE_SIZE;
    return bitsAsBytes.slice(start, start + defaults_1.BYTE_SIZE);
}; };
var combineByteIntoBit = function (accumulator, currentByte, i) {
    var shiftDistance = defaults_1.BYTE_SIZE - 1 - i;
    /* tslint:disable:no-bitwise */
    return (currentByte << shiftDistance) | accumulator;
    /* tslint:enable:no-bitwise */
};
var combineBufferIntoByte = function (buffer) { return buffer.reduce(combineByteIntoBit, 0); };
var combineBits = function (bitsAsBytes) {
    var n = Math.ceil(bitsAsBytes.length / defaults_1.BYTE_SIZE);
    return Array(n).fill(null).map(splitBitsAsBytes(bitsAsBytes)).map(combineBufferIntoByte);
};
var decode = function (data) {
    var bitsAsBytes = data.map(extractBinary);
    var combined = combineBits(bitsAsBytes);
    return Buffer.from(combined);
};
var messageMatchesShasum = function (message, shasum) { return (0, encryption_1.getShasumData)(message).equals(shasum); };
var extractData = function (imageData) {
    var rgb = imageData.filter(png_1.isRgbByte);
    var lengthDataSize = defaults_1.LENGTH_BYTES * defaults_1.BYTE_SIZE;
    var shasumDataSize = defaults_1.SHASUM_BYTES * defaults_1.BYTE_SIZE;
    var lengthAndShasumSize = lengthDataSize + shasumDataSize;
    var lengthData = rgb.slice(0, lengthDataSize);
    var decodedLengthData = decode(lengthData);
    var length = parseInt(decodedLengthData.toString('hex'), 16) * defaults_1.BYTE_SIZE;
    var shasumData = rgb.slice(lengthDataSize, lengthAndShasumSize);
    var decodedShasumData = decode(shasumData);
    var messageData = rgb.slice(lengthAndShasumSize, lengthAndShasumSize + length);
    var decodedMessageData = decode(messageData);
    if (!messageMatchesShasum(decodedMessageData, decodedShasumData))
        throw new Error('Shasum did not match decoded message');
    return decodedMessageData;
};
// export const reveal = (password: string) => (image: Buffer, encoding: BufferEncoding) => {
//   const png: PNG = PNG.sync.read(image);
//   const data = extractData(png.data);
//   const output = password ? decrypt(data, password) : data;
//   return encoding ? output.toString(encoding) : output;
// };
var reveal = function (image, encoding, password) {
    var png = pngjs_1.PNG.sync.read(image);
    var data = extractData(png.data);
    var output = password ? (0, encryption_1.decrypt)(data, password) : data;
    return encoding ? output.toString(encoding) : output;
};
exports.reveal = reveal;
